<!DOCTYPE html>
<!-- saved from url=(0045)http://threejs.org/examples/webgl_shaders_sky -->
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>three.js webgl - shaders - sky sun shader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>

			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
				text
			}

			#info {
				color:#333;
				text-shadow: 1px 1px #fff;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;

			}

			a {
				color: #333;
			}

		</style>

	    <style type="text/css">.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
        </style>

      <script type="x-shader/x-vertex" id="step07_vs">
			uniform float radiusX;
			uniform float radiusZ;
			uniform float size;
			uniform float scale;
			uniform float height;
			uniform float elapsedTime;
			uniform float speedH;
			uniform float speedV;

			void main() {
				vec3 pos = position;
				pos.x += cos((elapsedTime + position.z) * 0.25 * speedH) * radiusX;



				pos.y = mod(pos.y - elapsedTime * speedV, height);
				pos.z += sin((elapsedTime + position.x) * 0.25 * speedH) * radiusZ;

				vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );

				gl_PointSize = size * ( scale / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;
			}
		</script>
		
		<script type="x-shader/x-fragment" id="step09_fs">
			uniform vec3 color;
			uniform float opacity;
			uniform sampler2D texture;

			void main() {
				vec4 texColor = texture2D( texture, gl_PointCoord );
				gl_FragColor = texColor * vec4( color, opacity );
			}

		</script>

    </head>
	<body>

		<div id="info"><a href="http://threejs.org/" target="_blank">three.js</a> webgl - sky + sun shader

			<br><a href="https://plus.google.com/117614030945250277079/posts/MYkgKdvLhNj">More info</a> by <a href="http://twitter.com/blurspline">@blurspline</a>

		</div>

		<script src="./skySunShader_files/three.min.js"></script>

		<script src="./skySunShader_files/TrackballControls.js"></script>
		<script src="/lib/js/controls/OrbitControls.js"></script>
		<script src="/lib/js/Mirror.js"></script>
		<script src="./skySunShader_files/SkyShader.js"></script>

		<script src="./skySunShader_files/Detector.js"></script>
		<script src="./skySunShader_files/stats.min.js"></script>
		<script src="./skySunShader_files/dat.gui.min.js"></script>


		<script>


			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, controls, scene, renderer;

            var cameraControls;

			var WIDTH = window.innerWidth;
			var HEIGHT = window.innerHeight;

            var inclination,azimuth;

			var verticalMirror, groundMirror;

			var sky, sunSphere;
            var distance

            var directionalLight

            var particleSystemHeight = 500,
	            clock,
	            parameters,
	            onParametersUpdate,
	            texture;

			var times = 0;

            var time = 0;
            var speed = .01;

            window.onload = function() {
                init();
                animate();
            }

			function initSky(){

				// Add Sky Mesh
				sky = new THREE.Sky();
				scene.add( sky.mesh );


				// Add Sun Helper
				sunSphere = new THREE.Mesh( new THREE.SphereGeometry( 20000, 30, 30 ),
					new THREE.MeshBasicMaterial({color: 0xffffff, wireframe: false }));
				sunSphere.position.y = -700000;
				sunSphere.visible = true;
				scene.add( sunSphere );

				/// GUI

				var effectController  = {
					turbidity: 10,
					reileigh: 2,
					mieCoefficient: 0.005,
					mieDirectionalG: 0.8,
					luminance: 1,
					inclination: 0.49, // elevation / inclination
					azimuth: 0.25, // Facing front,					
					sun: !true
				}

				distance = 400000;

				function guiChanged() {
					var uniforms = sky.uniforms;
					uniforms.turbidity.value = effectController.turbidity;
					uniforms.reileigh.value = effectController.reileigh;
					uniforms.luminance.value = effectController.luminance;
					uniforms.mieCoefficient.value = effectController.mieCoefficient;
					uniforms.mieDirectionalG.value = effectController.mieDirectionalG;

                    inclination = effectController.inclination - 0.5;
                    azimuth = effectController.azimuth - 0.5;

					var theta = Math.PI * (effectController.inclination - 0.5);
					var phi = 2 * Math.PI * (effectController.azimuth - 0.5);

					//sunSphere.position.x = distance * Math.cos(phi);
					//sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta); 
					//sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta); 

					sunSphere.visible = effectController.sun;

					sky.uniforms.sunPosition.value.copy(sunSphere.position);

				}


				var gui = new dat.GUI();


				gui.add( effectController, "turbidity", 1.0, 20.0, 0.1 ).onChange( guiChanged );
				gui.add( effectController, "reileigh", 0.0, 4, 0.001 ).onChange( guiChanged );
				gui.add( effectController, "mieCoefficient", 0.0, 0.1, 0.001 ).onChange( guiChanged );
				gui.add( effectController, "mieDirectionalG", 0.0, 1, 0.001 ).onChange( guiChanged );
				gui.add( effectController, "luminance", 0.0, 2).onChange( guiChanged );;
				gui.add( effectController, "inclination", 0, 1, 0.0001).onChange( guiChanged );
				gui.add( effectController, "azimuth", 0, 1, 0.0001).onChange( guiChanged );
				gui.add( effectController, "sun").onChange( guiChanged );
				

				guiChanged();


				camera.lookAt(sunSphere.position)

	
			}


			function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.5, 2000000 );
				camera.position.z = 100;

				camera.position.y = 100;
				camera.setLens(20);

				scene = new THREE.Scene();

				var geometry = new THREE.IcosahedronGeometry( 5, 0 );
				var material = new THREE.MeshLambertMaterial( { color: 0xffffff, emissive: 0x333333, shading: THREE.FlatShading } );
				smallSphere = new THREE.Mesh( geometry, material );
				scene.add(smallSphere);	

                var geometry = new THREE.CylinderGeometry( 10, 5, 50, 8 );
				var material3 = new THREE.MeshLambertMaterial( { color: 0xffffff, emissive: 0x333333, shading: THREE.FlatShading } );

				mesh = new THREE.Mesh( geometry, material3 );
                mesh.rotation.x = 0;
                mesh.rotation.y = 0;
                mesh.rotation.z = Math.PI/2;
				
				mesh.position.y=15;

				scene.add( mesh );

				initSky();

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setSize( window.innerWidth, window.innerHeight );

				document.body.appendChild( renderer.domElement );

				cameraControls = new THREE.OrbitControls( camera, renderer.domElement );
                cameraControls.maxPolarAngle = Math.PI/2 - .01;
                cameraControls.minPolarAngle = .01;

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				document.body.appendChild( stats.domElement );

				//
                directionalLight = new THREE.DirectionalLight( 0xffffff, .7 );
                directionalLight.position.set( sunSphere.position.x, sunSphere.position.y, sunSphere.position.z);
                scene.add( directionalLight );

                var light = new THREE.AmbientLight( 0x0b0b0b ); // soft white light
                scene.add( light );

				hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
				hemiLight.color.setHSL( 0.6, 1, 0.6 );
				hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
				hemiLight.position.set( 0, 500, 0 );
				scene.add( hemiLight )

                // MIRORR planes
				var planeGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
				
				// MIRORR planes
				groundMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: WIDTH, textureHeight: HEIGHT, color: 0x777777 } );
				
				var mirrorMesh = new THREE.Mesh( planeGeo, groundMirror.material );
				mirrorMesh.add( groundMirror );
				mirrorMesh.rotateX( - Math.PI / 2 );
				scene.add( mirrorMesh );

				verticalMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: WIDTH, textureHeight: HEIGHT, color:0x889999 } );
				
				var verticalMirrorMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 60, 60 ), verticalMirror.material );
				verticalMirrorMesh.add( verticalMirror );
				verticalMirrorMesh.position.y = 35;
				verticalMirrorMesh.position.z = -45;
				//scene.add( verticalMirrorMesh );

				window.addEventListener( 'resize', onWindowResize, false );

                texture = THREE.ImageUtils.loadTexture( 'snowflake1.png' );
	
	            var numParticles = 100000,
		            width = 500,
		            height = particleSystemHeight,
		            depth = 500,
		            parameters = {
			            color: 0xFFFFFF,
			            height: particleSystemHeight,
			            radiusX: 2.5,
			            radiusZ: 2.5,
			            size: 100,
			            scale: 4.0,
			            opacity: 0.4,
			            speedH: 1.0,
			            speedV: 1.0
		            },
		            systemGeometry = new THREE.Geometry(),
		            systemMaterial = new THREE.ShaderMaterial({
			            uniforms: {
				            color:  { type: 'c', value: new THREE.Color( parameters.color ) },
				            height: { type: 'f', value: parameters.height },
				            elapsedTime: { type: 'f', value: 0 },
				            radiusX: { type: 'f', value: parameters.radiusX },
				            radiusZ: { type: 'f', value: parameters.radiusZ },
				            size: { type: 'f', value: parameters.size },
				            scale: { type: 'f', value: parameters.scale },
				            opacity: { type: 'f', value: parameters.opacity },
				            texture: { type: 't', value: texture },
				            speedH: { type: 'f', value: parameters.speedH },
				            speedV: { type: 'f', value: parameters.speedV }
			            },
			            vertexShader: document.getElementById( 'step07_vs' ).textContent,
			            fragmentShader: document.getElementById( 'step09_fs' ).textContent,
			            blending: THREE.AdditiveBlending,
			            transparent: true,
			            depthTest: false
		            });
             
	            for( var i = 0; i < numParticles; i++ ) {
		            var vertex = new THREE.Vector3(
				            rand( width ),
				            Math.random() * height,
				            rand( depth )
			            );

		            systemGeometry.vertices.push( vertex );
	            }

	            particleSystem = new THREE.ParticleSystem( systemGeometry, systemMaterial );
	            particleSystem.position.y = -height/2;

	            scene.add( particleSystem );

	            clock = new THREE.Clock();

	            document.body.appendChild( renderer.domElement );

	            onParametersUpdate = function( v ) {
		            systemMaterial.uniforms.color.value.set( parameters.color );
		            systemMaterial.uniforms.height.value = parameters.height;
		            systemMaterial.uniforms.radiusX.value = parameters.radiusX;
		            systemMaterial.uniforms.radiusZ.value = parameters.radiusZ;
		            systemMaterial.uniforms.size.value = parameters.size;
		            systemMaterial.uniforms.scale.value = parameters.scale;
		            systemMaterial.uniforms.opacity.value = parameters.opacity;
		            systemMaterial.uniforms.speedH.value = parameters.speedH;
		            systemMaterial.uniforms.speedV.value = parameters.speedV;
	            }

	            controls = new dat.GUI();
	            controls.close();

	            controls.addColor( parameters, 'color' ).onChange( onParametersUpdate );
	            controls.add( parameters, 'height', 0, particleSystemHeight * 2.0 ).onChange( onParametersUpdate );
	            controls.add( parameters, 'radiusX', 0, 10 ).onChange( onParametersUpdate );
	            controls.add( parameters, 'radiusZ', 0, 10 ).onChange( onParametersUpdate );
	            controls.add( parameters, 'size', 1, 400 ).onChange( onParametersUpdate );
	            controls.add( parameters, 'scale', 1, 30 ).onChange( onParametersUpdate );
	            controls.add( parameters, 'opacity', 0, 1 ).onChange( onParametersUpdate );
	            controls.add( parameters, 'speedH', 0.1, 3 ).onChange( onParametersUpdate );
	            controls.add( parameters, 'speedV', 0.1, 3 ).onChange( onParametersUpdate );



			}


            function rand( v ) {
	            return (v * (Math.random() - 0.5));
            }


			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}



			function animate() {

				// render (update) the mirrors
				groundMirror.renderWithMirror( verticalMirror );
				//verticalMirror.renderWithMirror( groundMirror );

				time = Date.now();

				requestAnimationFrame( animate );

                var delta = clock.getDelta(),
		        elapsedTime = clock.getElapsedTime();

	            particleSystem.material.uniforms.elapsedTime.value = elapsedTime * 10;


                times += 1;
				
				if (times<200){
					
				}else if (times<300){
					speed+=.001;

				}else if (times<400){
					speed-=.001;

				}else{
					times=0;
					speed=.01;
				}


				mesh.rotation.x += 0.0;
				mesh.rotation.y += speed;
				mesh.rotation.z += 0.0;

				
				var timer = Date.now() * .01;

				
				smallSphere.position.set(
					Math.cos( timer * 0.1 ) * 50,
					Math.abs( Math.cos( timer * 0.2 ) ) * 20 + 5,
					Math.sin( timer * 0.1 ) * 50
				);
				smallSphere.rotation.y = ( Math.PI / 2 ) - timer * 0.1;
				smallSphere.rotation.z = timer * 0.8;

                azimuth += .001;
                azimuth %= 1;

				var theta = Math.PI * (inclination - 0.5);
				var phi = 2 * Math.PI * (azimuth - 0.5);

				sunSphere.position.x = distance * Math.cos(phi);
				sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta); 
				sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta); 

                directionalLight.position= sunSphere.position;

				sky.uniforms.sunPosition.value.copy(sunSphere.position);

				cameraControls.update();

				render();

			}

			function render() {

				renderer.render( scene, camera );
				stats.update();

			}


		</script>
  
    </body>
</html>
